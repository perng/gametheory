
=== GTChat - Chatroom based on Websocket ===

By: X. Chen
Last modified: 3/18/2015


== About ==

This package is a chatroom implemented using using python/autobahn/twisted websocket. 

This is extended from the previous broadcastdemo package, and will be a testing client for the gametheory server. 
The concept is to build a simplified and specific server, and a fully functioning client based on this. The client
can can be used to test the more complex and generic gametheory server.

Basically, it's a chatroom: when server is started, a client can connect to the server and join a room,
then send message to all other clients. 

This can be easily extended to other multi-user games, from 2 players to any number of players.


== Server API ==

Communication is done in Json. 

No persistence is used at this time, user data is cached in memory.

commands: register, login, update_pwd, create_room, invite, join_room, leave_room, speak

-- register
{"cmd":"register","usr":"username","pwd":"password"}

Password should be at least 8 chars in length.

In case of mobile user, usr/pwd can be replaced by uuid. 
But often the user also will pick up a nickname (which servers as usr here).

-- login
# server expects to receive:
For regisered user:
{"cmd":"login", "type":"reg", "usr":"user1","pwd":"password"}

For unregistered temporary user:
{"cmd":"login", "type":"tmp", "usr":"user2"}

# server will send to this client:
ok(session_id, user list, room list)/fail

-- update_pwd
# server expects to receive:
{"cmd":"update_pwd", "usr":"username", "pwd":"old_pwd", "new_pwd":"pwd", "new_pwd2":"pwd"}

# server will send to this client:
ok/fail

-- create_room
# server expects to receive:
{"cmd":"create_room", "room_name":"room1", "usr":"user1"}

# server will send to this client:
ok (the client should add user to this new chatroom)/fail
# server will send to all clients:
new room created.

-- invite
# server expects to receive:
{"cmd":"invite", "room_name":"room1", "invitee":"user2", "usr":"user1"}

# server will send to invitee:
invite information (room_name, inviter)

-- join_room
# server expects to receive:
{"cmd":"join_room", "room_name":"room1", "usr":"user1"}

# server will send to this client:
ok (room information: users in room, the client then will put this user to the room)/fail
# server will send to all clients in this room:
new client in room

-- leave_room
# server expects to receive:
{"cmd":"leave_room", "room_name":"room1", "usr":"user1"}

# server will send to this client:
ok (the client will remove the user from the room)/fail (optional)
# server will send to all clients in this room:
new client in room

-- speak
# server expects to receive:
{"cmd":"speak", "room_name":"room1", "usr":"user1", "msg":"to room1 only"}

# server will send to this client:
ok/fail (optional)
# server will send to all clients in this room:
message

-- broadcast
# this is available only to superuser, who has access to broadcast_key.
# server expects to receive:
{"cmd":"speak", "usr":"user1", "broadcast_key", "msg":"broadcast"}

# server will send to all clients
message.


Examples:

>>> General test.

{"cmd":"register","usr":"user1","pwd":"pwd1abcd"}
{"cmd":"register","usr":"user2","pwd":"pwd1efgh"}
{"cmd":"update_pwd", "usr":"user1", "pwd":"pwd1abcd", "new_pwd":"12345678", "new_pwd2":"12345678"}
{"cmd":"login", "type":"reg", "usr":"user2","pwd":"pwd1efgh"}
{"cmd":"login", "type":"tmp", "usr":"user2"}

{"cmd":"create_room", "room_name":"nerdhaus", "usr":"user2"}
{"cmd":"create_room", "room_name":"nerdhaus", "usr":"user3"}
{"cmd":"create_room", "room_name":"nerdhaus", "usr":"user2"}

{"cmd":"login", "type":"tmp", "usr":"anonymous"}
{"cmd":"join_room", "room_name":"nerdhaus", "usr":"anonymous"}
{"cmd":"leave_room", "room_name":"nerdhaus", "usr":"anonymous"}
{"cmd":"leave_room", "room_name":"nerdhaus", "usr":"user2"}

{"cmd":"speak", "room_name":"nerdhaus", "usr":"user2", "msg":"to nerdhaus"}

>>> test chatroom boardcast

# client 1
{"cmd":"register","usr":"user1","pwd":"pwd1abcd"}
{"cmd":"login", "type":"reg", "usr":"user1", "pwd":"pwd1abcd"}
{"cmd":"create_room", "room_name":"nerdhaus", "usr":"user1"}

# client 2
{"cmd":"register","usr":"user2","pwd":"pwd1abcd"}
{"cmd":"login", "type":"reg", "usr":"user2", "pwd":"pwd1abcd"}
{"cmd":"join_room", "room_name":"nerdhaus", "usr":"user2"}

# client 3
{"cmd":"register","usr":"user3","pwd":"pwd1abcd"}
{"cmd":"login", "type":"reg", "usr":"user3", "pwd":"pwd1abcd"}

# only client 2 should receive this. (client 1 sent this himself)
{"cmd":"speak", "room_name":"nerdhaus", "usr":"user1", "msg":"to nerdhaus only"}

# only client 3 should receive this, since he is the one being invited.
{"cmd":"invite", "room_name":"nerdhaus", "invitee":"user3", "usr":"user1"}


>>> Other notes:

# Right now there is this problem: multiple-login: a user login multiple times.
# Ideally it should be solved this way: if a user login from a new location,
# the previous one should be kicked out.
#
# Also for user valication, each time should validate his src also:
# i.e., only when both usr and src match, it's valid. This prevents
# identity spoofing.
#
# Basically:
# - from one src there can be only one active user
# - one active user can be from only one src


== Client API ==


== Code ==

client.py and server.py are from:
[1] https://github.com/tavendo/AutobahnPython/tree/master/examples/twisted/websocket/broadcast
[2] http://autobahn.ws/python/websocket/examples.html

client.html is from:
[3] https://github.com/tavendo/AutobahnPython/blob/master/examples/twisted/websocket/echo/client.html

Modified client.py to add the function of getting console stdio input from user.
Modified server.py to avoid sending to self when broadcast, and added class API_Chatroom.
Modified client.html to add the textbox for user input, and modified output format.

== Usage ==

To start server:
$ ./s.sh

To start client:
$ ./c.sh

To exit server or client from console, press Ctrl-C.

To start client.html in a browser:
open client.html in a browser.


== Change Log ==

-- 3/18/2015 --
Creation.


