
=== GTChat - Chatroom based on Websocket ===

By: X. Chen
Last modified: 3/19/2015


== About ==

This package is a chatroom implemented using using python/autobahn/twisted websocket. 

This is extended from the previous broadcastdemo package, and will be a testing client for the gametheory server. 
The concept is to build a simplified and specific server, and a fully functioning client based on this. The client
can can be used to test the more complex and generic gametheory server.

Basically, it's a chatroom: when server is started, a client can connect to the server and join a room,
then send message to all other clients. 

This can be easily extended to other multi-user games, from 2 players to any number of players.


== Server API ==

Communication is done in Json. 

No persistence is used at this time, user data is cached in memory.

commands: register, login, update_pwd, create_room, invite, join_room, leave_room, speak

-- register
{"cmd":"register","usr":"username","pwd":"password"}

Password should be at least 8 chars in length.

In case of mobile user, usr/pwd can be replaced by uuid. 
But often the user also will pick up a nickname (which servers as usr here).

-- login
# server expects to receive:
For regisered user:
{"cmd":"login", "type":"reg", "usr":"user1","pwd":"password"}

For unregistered temporary user:
{"cmd":"login", "type":"tmp", "usr":"user2"}

# server will send to this client:
ok(session_id, user list, room list)/fail

-- update_pwd
# only a logged in user can change his/her password.
# server expects to receive:
{"cmd":"update_pwd", "pwd":"old_pwd", "new_pwd":"pwd", "new_pwd2":"pwd"}

# server will send to this client:
ok/fail

-- create_room
# server expects to receive:
{"cmd":"create_room", "room_name":"room1"}

# server will send to this client:
ok (the client should add user to this new chatroom)/fail
# server will send to all clients:
new room created.

-- invite
# server expects to receive:
{"cmd":"invite", "room_name":"room1", "invitee":"user2"}
# conditions: usr is in room, invitee is not.

# server will send to invitee:
{"cmd":"c_invited", "msg":msg, "room_name":room_name, "usr":usr}
# c_invited is a client side API call, that client should handle for properly display.

-- join_room
# server expects to receive:
{"cmd":"join_room", "room_name":"room1"}
# condition: usr is not in the room yet.

# server will send to this client:
ok (room information: users in room, the client then will put this user to the room)/fail
# server will send to all clients in this room:
new client in room

-- leave_room
# server expects to receive:
{"cmd":"leave_room", "room_name":"room1"}
# condition: usr is in the room.

# server will send to this client:
ok (the client will remove the user from the room)/fail (optional)
# server will send to all clients in this room:
new client in room

-- speak
# server expects to receive:
{"cmd":"speak", "room_name":"room1", "msg":"to room1 only"}

# server will send to this client:
ok/fail (optional)
# server will send to all other clients in this room:
{"cmd":"c_speak", "msg":msg, "usr":usr, "room_name":room_name}
c_speak is a client side API call, that should be handled by client for proper display.

-- broadcast 
# this is available only to superuser, who has access to broadcast_key.
# server expects to receive:
{"cmd":"broadcast", "broadcast_key", "msg":"broadcast"}

# server will send to all clients
message.

-- exit
# server expects to receive:
{"cmd":"exit"}

# For a proper exit, the user should be removed from chat room if any, 
# and also clear its entry in storage.

# server will send this update to clients in the room
user exit from room.
# server will send this update to all clients (optional, can be expensive)


Examples:

>>> General test.

{"cmd":"register","usr":"user1","pwd":"pwd1abcd"}
{"cmd":"register","usr":"user2","pwd":"pwd1efgh"}
{"cmd":"update_pwd", "pwd":"pwd1abcd", "new_pwd":"12345678", "new_pwd2":"12345678"}
{"cmd":"login", "type":"reg", "usr":"user2","pwd":"pwd1efgh"}
{"cmd":"login", "type":"tmp", "usr":"user2"}

{"cmd":"create_room", "room_name":"nerdhaus"}

{"cmd":"login", "type":"tmp", "usr":"anonymous"}
{"cmd":"join_room", "room_name":"nerdhaus"}
{"cmd":"leave_room", "room_name":"nerdhaus"}

{"cmd":"speak", "room_name":"nerdhaus", "msg":"to nerdhaus"}

>>> test chatroom boardcast

# client 1
{"cmd":"register","usr":"user1","pwd":"pwd1abcd"}
{"cmd":"login", "type":"reg", "usr":"user1", "pwd":"pwd1abcd"}
{"cmd":"create_room", "room_name":"nerdhaus"}

# client 2
{"cmd":"register","usr":"user2","pwd":"pwd1abcd"}
{"cmd":"login", "type":"reg", "usr":"user2", "pwd":"pwd1abcd"}
{"cmd":"join_room", "room_name":"nerdhaus"}

# client 3
{"cmd":"register","usr":"user3","pwd":"pwd1abcd"}
{"cmd":"login", "type":"reg", "usr":"user3", "pwd":"pwd1abcd"}

# only client 2 should receive this. (client 1 sent this himself)
{"cmd":"speak", "room_name":"nerdhaus", "msg":"to nerdhaus only"}

# only client 3 should receive this, since he is the one being invited.
{"cmd":"invite", "room_name":"nerdhaus", "invitee":"user3"}


>>> test invite
client 1:
{"cmd":"register","usr":"user1","pwd":"pwd1abcd"}
{"cmd":"login", "type":"reg", "usr":"user1", "pwd":"pwd1abcd"}
{"cmd":"create_room", "room_name":"nerdhaus"}
client 2:
{"cmd":"register","usr":"user2","pwd":"pwd1abcd"}
{"cmd":"login", "type":"reg", "usr":"user2", "pwd":"pwd1abcd"}

client 3:
{"cmd":"register","usr":"user3","pwd":"pwd1abcd"}
{"cmd":"login", "type":"reg", "usr":"user3", "pwd":"pwd1abcd"}

client 1:
{"cmd":"invite", "invitee":"user2", "room_name":"nerdhaus"}
# only client2 should receive this.

client 2:
{"cmd":"join_room", "room_name":"nerdhaus"}
{"cmd":"speak", "room_name":"nerdhaus", "msg":"to nerdhaus"}


== Security Issues ==

# Right now there is this problem: multiple-login: a user login multiple times.
# Ideally it should be solved this way: if a user login from a new location,
# the previous one should be kicked out.
#
# Also for user valication, each time should validate his src also:
# i.e., only when both usr and src match, it's valid. This prevents
# identity spoofing.
#
# Basically:
# - from one src there can be only one active user
# - one active user can be from only one src

(usr, src) is a pair that should match for a single user.

1) If from the same src come 2 or more different usrs, that can be identity spoofing.

In this case, the second usr's messages should be dropped, and a warning returned 
(or nothing returned at all, to save bandwidth).

2) If from the same usr comes from different srcs, the user may be logged in from different locations.

In this case, one can either:
a) not allow it, auto logout from the first src,
b) allow it, and maybe attach a seq_no to the latter connections.

Well, ideally, a person should be able to log in multiple sessions, like in QQ and gtalk, 
so he can be in multiple rooms at the same time. So, maybe should use src as index key, not usr.  
If a user log in with different session, he will have different src (port number).

Then in T_users_active, use src as key, username becomes a field value. Can assign a session_id to be used.

So for every request from the same src, use the associated username for all requests; 
unless it's a login request with different username, then it may be a spoof, 
just either 1) drop new login request, or 2) terminate old session. 
Guess will go with the 2nd case, since it's always possible a user have different accounts, 
but a previous account may not be shutdown due to networking issues.  
For case 2), also there is no need to unregister the client, just flush and replace 
the user's information in T_users_active, and kick the previous user out from all chatrooms if any.

The only issue with this, is that if the invited person has multiple login sessions, 
which one to invite? A easy answer is: any one of the active sessions. 
So can use a reverse hash of usr=>src for this, which only needs to keep one usr session's src.


== Client API ==


== Code ==

client.py and server.py are from:
[1] https://github.com/tavendo/AutobahnPython/tree/master/examples/twisted/websocket/broadcast
[2] http://autobahn.ws/python/websocket/examples.html

client.html is from:
[3] https://github.com/tavendo/AutobahnPython/blob/master/examples/twisted/websocket/echo/client.html

Modified client.py to add the function of getting console stdio input from user.
Modified server.py to avoid sending to self when broadcast, and added class API_Chatroom.
Modified client.html to add the textbox for user input, and modified output format.

== Usage ==

To start server:
$ ./s.sh

To start client:
$ ./c.sh

To exit server or client from console, press Ctrl-C.

To start client.html in a browser:
open client.html in a browser.


== Change Log ==

-- 3/19/2015 --
* Finished change to use src to index T_users_active instead of username, to avoid identity spoofing.
* As a consequence, now only commands 'register' and 'login' need to provide user name.
* Also added api_exit API call. 

-- 3/18/2015 --
Creation.


