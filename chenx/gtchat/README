
=== GTChat - Chatroom based on Websocket ===

By: X. Chen
Created on: 3/18/2015
Last modified: 3/19/2015


== About ==

This package is a chatroom implemented using using python/autobahn/twisted websocket. 

This is extended from the previous broadcastdemo package, and will be a testing client for the gametheory server. 
The concept is to build a simplified and specific server, and a fully functioning client based on this. The client
can can be used to test the more complex and generic gametheory server.

Basically, it's a chatroom: when server is started, a client can connect to the server and join a room,
then send message to all other clients. 

This can be easily extended to other multi-user games, from 2 players to any number of players.


== Server API ==

Communication is done in Json. 

No persistence is used at this time, user data is cached in memory.

commands: 
register, login, update_pwd, create_room, invite, join_room, leave_room, speak, whisper, broadcast, 
admin_show_table

-- register
{"cmd":"register","usr":"username","pwd":"password"}

Password should be at least 8 chars in length.

In case of mobile user, usr/pwd can be replaced by uuid. 
But often the user also will pick up a nickname (which servers as usr here).

-- login
# server expects to receive:
For regisered user:
{"cmd":"login", "type":"reg", "usr":"user1","pwd":"password"}

For unregistered temporary user:
{"cmd":"login", "type":"tmp", "usr":"user2"}

# server will send to this client:
ok(session_id, user list, room list)/fail

-- update_pwd
# only a logged in user can change his/her password.
# server expects to receive:
{"cmd":"update_pwd", "pwd":"old_pwd", "new_pwd":"pwd", "new_pwd2":"pwd"}

# server will send to this client:
ok/fail

-- create_room
# server expects to receive:
{"cmd":"create_room", "room_name":"room1"}

# server will send to this client:
ok (the client should add user to this new chatroom)/fail
# server will send to all clients:
new room created.

-- invite
# server expects to receive:
{"cmd":"invite", "room_name":"room1", "invitee":"user2"}
# conditions: usr is in room, invitee is not.

# server will send to invitee:
{"cmd":"c_invited", "msg":msg, "room_name":room_name, "usr":usr}
# c_invited is a client side API call, that client should handle for properly display.

-- join_room
# server expects to receive:
{"cmd":"join_room", "room_name":"room1"}
# condition: usr is not in the room yet.

# server will send to this client:
ok (room information: users in room, the client then will put this user to the room)/fail
# server will send to all clients in this room:
new client in room

-- leave_room
# server expects to receive:
{"cmd":"leave_room", "room_name":"room1"}
# condition: usr is in the room.

# server will send to this client:
ok (the client will remove the user from the room)/fail (optional)
# server will send to all clients in this room:
new client in room

-- speak
# server expects to receive:
{"cmd":"speak", "room_name":"room1", "msg":"to room1 only"}

# server will send to this client:
ok/fail (optional)
# server will send to all other clients in this room:
{"cmd":"c_speak", "msg":msg, "usr":usr, "room_name":room_name}
c_speak is a client side API call, that should be handled by client for proper display.

-- whisper
# this is to send private message to a singler person anywhere, not tied to a room.
# server expects to receive:
{"cmd":"whisper", "target_user":usr, "msg":"message"}

-- broadcast 
# this should be available only to users with broadcast permission, such as admin.
# server expects to receive:
{"cmd":"broadcast", "msg":"message"}

# server will send to all clients
message.

-- admin_show_table
# this should be available only to admin, for admin/testing purposes.
# server expects to receive:
{"cmd":"admin_show_table", "table":"table_name"}

-- exit
# server expects to receive:
{"cmd":"exit"}

# For a proper exit, the user should be removed from chat room if any, 
# and also clear its entry in storage.

# server will send this update to clients in the room
user exit from room.
# server will send this update to all clients (optional, can be expensive)


Examples:

>>> General test.

{"cmd":"register","usr":"user1","pwd":"pwd1abcd"}
{"cmd":"register","usr":"user2","pwd":"pwd1efgh"}
{"cmd":"update_pwd", "pwd":"pwd1abcd", "new_pwd":"12345678", "new_pwd2":"12345678"}
{"cmd":"login", "type":"reg", "usr":"user2","pwd":"pwd1efgh"}
{"cmd":"login", "type":"tmp", "usr":"user2"}

{"cmd":"create_room", "room_name":"nerdhaus"}

{"cmd":"login", "type":"tmp", "usr":"anonymous"}
{"cmd":"join_room", "room_name":"nerdhaus"}
{"cmd":"leave_room", "room_name":"nerdhaus"}

{"cmd":"speak", "room_name":"nerdhaus", "msg":"to nerdhaus"}

>>> test chatroom boardcast

# client 1
{"cmd":"register","usr":"user1","pwd":"pwd1abcd"}
{"cmd":"login", "type":"reg", "usr":"user1", "pwd":"pwd1abcd"}
{"cmd":"create_room", "room_name":"nerdhaus"}

# client 2
{"cmd":"register","usr":"user2","pwd":"pwd1abcd"}
{"cmd":"login", "type":"reg", "usr":"user2", "pwd":"pwd1abcd"}
{"cmd":"join_room", "room_name":"nerdhaus"}

# client 3
{"cmd":"register","usr":"user3","pwd":"pwd1abcd"}
{"cmd":"login", "type":"reg", "usr":"user3", "pwd":"pwd1abcd"}

# only client 2 should receive this. (client 1 sent this himself)
{"cmd":"speak", "room_name":"nerdhaus", "msg":"to nerdhaus only"}

# only client 3 should receive this, since he is the one being invited.
{"cmd":"invite", "room_name":"nerdhaus", "invitee":"user3"}


>>> test invite

client 1:
{"cmd":"register","usr":"user1","pwd":"pwd1abcd"}
{"cmd":"login", "type":"reg", "usr":"user1", "pwd":"pwd1abcd"}
{"cmd":"create_room", "room_name":"nerdhaus"}

client 2:
{"cmd":"register","usr":"user2","pwd":"pwd1abcd"}
{"cmd":"login", "type":"reg", "usr":"user2", "pwd":"pwd1abcd"}

client 3:
{"cmd":"register","usr":"user3","pwd":"pwd1abcd"}
{"cmd":"login", "type":"reg", "usr":"user3", "pwd":"pwd1abcd"}

client 1:
{"cmd":"invite", "invitee":"user2", "room_name":"nerdhaus"}
# only client2 should receive this.

client 2:
{"cmd":"join_room", "room_name":"nerdhaus"}
{"cmd":"speak", "room_name":"nerdhaus", "msg":"to nerdhaus"}

>>> test api_whisper: 
{"cmd":"whisper","target_user":"user2","msg":"I'm whispering .. "}
      
>>> api_broadcast: 
{"cmd":"broadcast", "msg":"I'm broadcasting .. "}
      
>>> api_admin_show_table: 
# for the purpose of returning table contents to client, for admin/testing purpose only.
{"cmd":"admin_show_table", "table":"table_name"}
{"cmd":"admin_show_table", "table":"T_users"}
{"cmd":"admin_show_table", "table":"T_users_active"}
{"cmd":"admin_show_table", "table":"T_users_src"}
{"cmd":"admin_show_table", "table":"T_rooms"}


== Security Issues ==

# Right now there is this problem: multiple-login: a user login multiple times.
# Ideally it should be solved this way: if a user login from a new location,
# the previous one should be kicked out.
#
# Also for user valication, each time should validate his src also:
# i.e., only when both usr and src match, it's valid. This prevents
# identity spoofing.
#
# Basically:
# - from one src there can be only one active user
# - one active user can be from only one src, or alternatively can be logged in from multiple places.

#
# Considerations
#

(usr, src) is a pair that should match for a single user.

1) If from the same src come 2 or more different usrs, that can be identity spoofing.

In this case, the second usr's messages should be dropped, and a warning returned 
(or nothing returned at all, to save bandwidth).

2) If from the same usr comes from different srcs, the user may be logged in from different locations.

In this case, one can either:
a) not allow it, auto logout from the first src,
b) allow it, and maybe attach a seq_no to the latter connections.

Well, ideally, a person should be able to log in multiple sessions, like in QQ and gtalk, 
so he can be in multiple rooms at the same time. So, maybe should use src as index key, not usr.  
If a user log in with different session, he will have different src (port number).

Then in T_users_active, use src as key, username becomes a field value. Can assign a session_id to be used.

So for every request from the same src, use the associated username for all requests; 
unless it's a login request with different username, then it may be a spoof, 
just either 1) drop new login request, or 2) terminate old session. 
Guess will go with the 2nd case, since it's always possible a user have different accounts, 
but a previous account may not be shutdown due to networking issues.  
For case 2), also there is no need to unregister the client, just flush and replace 
the user's information in T_users_active, and kick the previous user out from all chatrooms if any.

The only issue with this, is that if the invited person has multiple login sessions, 
which one to invite? A easy answer is: any one of the active sessions.
A probable good answer is: the last logged in session, since it may be the most active.
So can use a hash of usr=>src for this, which only needs to keep src of the user's lastest session.


#
# Summary on the final design: (this design has been fully implemented)
#
 * Allow a user to have multiple login sessions
 * Each session is identified by the connection src (i.e., src == client.peer == tcp4:ip:port).
   This essentially means that the connection src (tcp4:ip:port) is used as a session_id that cannot be spoofed.
 * Only 'register' and 'login' requests provide user name, all other requests will obtain user name from src.
 * This way, one cannot spoof the identity of another user by attaching the user name in request as in previous design.
 * If a second 'login' request comes in an active connection src, then:
   1) if user name is the same, then abort the login request, since the user is already logged in.
   2) if user name is different, this probably is the same user is logging in with a different account, 
      and didn't properly shutdown the previous session. In this case, clean up the previous session
      (drop the previous account from chatroom, and clean up relevant storage), and initialize the new session.


== Client API ==


== Code ==

client.py and server.py are from:
[1] https://github.com/tavendo/AutobahnPython/tree/master/examples/twisted/websocket/broadcast
[2] http://autobahn.ws/python/websocket/examples.html

client.html is from:
[3] https://github.com/tavendo/AutobahnPython/blob/master/examples/twisted/websocket/echo/client.html

Modified client.py to add the function of getting console stdio input from user.
Modified server.py to avoid sending to self when broadcast, and added class API_Chatroom.
Modified client.html to add the textbox for user input, and modified output format.

== Usage ==

To start server:
$ ./s.sh

To start client:
$ ./c.sh

To exit server or client from console, press Ctrl-C.

To start client.html in a browser:
open client.html in a browser.


== Change Log ==

-- 3/19/2015 --
* Finished change to use src to index T_users_active instead of username, to avoid identity spoofing.
* As a consequence, now only commands 'register' and 'login' need to provide user name.
* Also added api_exit API call. 

-- 3/18/2015 --
Creation.


